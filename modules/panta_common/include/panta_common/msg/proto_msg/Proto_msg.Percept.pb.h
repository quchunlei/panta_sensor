// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Proto_msg.Percept.proto

#ifndef PROTOBUF_Proto_5fmsg_2ePercept_2eproto__INCLUDED
#define PROTOBUF_Proto_5fmsg_2ePercept_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Proto_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Proto_5fmsg_2ePercept_2eproto();
void protobuf_AssignDesc_Proto_5fmsg_2ePercept_2eproto();
void protobuf_ShutdownFile_Proto_5fmsg_2ePercept_2eproto();

class Point3;
class FreeSpace;
class Obstacle;
class FreeSpaces;
class Obstacles;

enum Obstacle_Type {
  Obstacle_Type_UNKNOWN = 0,
  Obstacle_Type_PEDESTRIAN = 1,
  Obstacle_Type_BICYCLE = 2,
  Obstacle_Type_CAR = 3,
  Obstacle_Type_TRUCK_BUS = 4,
  Obstacle_Type_ULTRA_VEHICLE = 5
};
bool Obstacle_Type_IsValid(int value);
const Obstacle_Type Obstacle_Type_Type_MIN = Obstacle_Type_UNKNOWN;
const Obstacle_Type Obstacle_Type_Type_MAX = Obstacle_Type_ULTRA_VEHICLE;
const int Obstacle_Type_Type_ARRAYSIZE = Obstacle_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Obstacle_Type_descriptor();
inline const ::std::string& Obstacle_Type_Name(Obstacle_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Obstacle_Type_descriptor(), value);
}
inline bool Obstacle_Type_Parse(
    const ::std::string& name, Obstacle_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Obstacle_Type>(
    Obstacle_Type_descriptor(), name, value);
}
enum Obstacle_MotionType {
  Obstacle_MotionType_UNKNOW = 0,
  Obstacle_MotionType_MOVING = 1,
  Obstacle_MotionType_STATIC = 2,
  Obstacle_MotionType_STOPED = 3
};
bool Obstacle_MotionType_IsValid(int value);
const Obstacle_MotionType Obstacle_MotionType_MotionType_MIN = Obstacle_MotionType_UNKNOW;
const Obstacle_MotionType Obstacle_MotionType_MotionType_MAX = Obstacle_MotionType_STOPED;
const int Obstacle_MotionType_MotionType_ARRAYSIZE = Obstacle_MotionType_MotionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Obstacle_MotionType_descriptor();
inline const ::std::string& Obstacle_MotionType_Name(Obstacle_MotionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Obstacle_MotionType_descriptor(), value);
}
inline bool Obstacle_MotionType_Parse(
    const ::std::string& name, Obstacle_MotionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Obstacle_MotionType>(
    Obstacle_MotionType_descriptor(), name, value);
}
// ===================================================================

class Point3 : public ::google::protobuf::Message {
 public:
  Point3();
  virtual ~Point3();

  Point3(const Point3& from);

  inline Point3& operator=(const Point3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point3& default_instance();

  void Swap(Point3* other);

  // implements Message ----------------------------------------------

  Point3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point3& from);
  void MergeFrom(const Point3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:Proto_msg.Point3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_Proto_5fmsg_2ePercept_2eproto();
  friend void protobuf_AssignDesc_Proto_5fmsg_2ePercept_2eproto();
  friend void protobuf_ShutdownFile_Proto_5fmsg_2ePercept_2eproto();

  void InitAsDefaultInstance();
  static Point3* default_instance_;
};
// -------------------------------------------------------------------

class FreeSpace : public ::google::protobuf::Message {
 public:
  FreeSpace();
  virtual ~FreeSpace();

  FreeSpace(const FreeSpace& from);

  inline FreeSpace& operator=(const FreeSpace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FreeSpace& default_instance();

  void Swap(FreeSpace* other);

  // implements Message ----------------------------------------------

  FreeSpace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FreeSpace& from);
  void MergeFrom(const FreeSpace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // optional uint32 device_code = 2;
  inline bool has_device_code() const;
  inline void clear_device_code();
  static const int kDeviceCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 device_code() const;
  inline void set_device_code(::google::protobuf::uint32 value);

  // optional float distance = 3;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 3;
  inline float distance() const;
  inline void set_distance(float value);

  // optional float yaw_angle = 4;
  inline bool has_yaw_angle() const;
  inline void clear_yaw_angle();
  static const int kYawAngleFieldNumber = 4;
  inline float yaw_angle() const;
  inline void set_yaw_angle(float value);

  // optional float free_prob = 5;
  inline bool has_free_prob() const;
  inline void clear_free_prob();
  static const int kFreeProbFieldNumber = 5;
  inline float free_prob() const;
  inline void set_free_prob(float value);

  // @@protoc_insertion_point(class_scope:Proto_msg.FreeSpace)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_device_code();
  inline void clear_has_device_code();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_yaw_angle();
  inline void clear_has_yaw_angle();
  inline void set_has_free_prob();
  inline void clear_has_free_prob();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double timestamp_;
  ::google::protobuf::uint32 device_code_;
  float distance_;
  float yaw_angle_;
  float free_prob_;
  friend void  protobuf_AddDesc_Proto_5fmsg_2ePercept_2eproto();
  friend void protobuf_AssignDesc_Proto_5fmsg_2ePercept_2eproto();
  friend void protobuf_ShutdownFile_Proto_5fmsg_2ePercept_2eproto();

  void InitAsDefaultInstance();
  static FreeSpace* default_instance_;
};
// -------------------------------------------------------------------

class Obstacle : public ::google::protobuf::Message {
 public:
  Obstacle();
  virtual ~Obstacle();

  Obstacle(const Obstacle& from);

  inline Obstacle& operator=(const Obstacle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Obstacle& default_instance();

  void Swap(Obstacle* other);

  // implements Message ----------------------------------------------

  Obstacle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Obstacle& from);
  void MergeFrom(const Obstacle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Obstacle_Type Type;
  static const Type UNKNOWN = Obstacle_Type_UNKNOWN;
  static const Type PEDESTRIAN = Obstacle_Type_PEDESTRIAN;
  static const Type BICYCLE = Obstacle_Type_BICYCLE;
  static const Type CAR = Obstacle_Type_CAR;
  static const Type TRUCK_BUS = Obstacle_Type_TRUCK_BUS;
  static const Type ULTRA_VEHICLE = Obstacle_Type_ULTRA_VEHICLE;
  static inline bool Type_IsValid(int value) {
    return Obstacle_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Obstacle_Type_Type_MIN;
  static const Type Type_MAX =
    Obstacle_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Obstacle_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Obstacle_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Obstacle_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Obstacle_Type_Parse(name, value);
  }

  typedef Obstacle_MotionType MotionType;
  static const MotionType UNKNOW = Obstacle_MotionType_UNKNOW;
  static const MotionType MOVING = Obstacle_MotionType_MOVING;
  static const MotionType STATIC = Obstacle_MotionType_STATIC;
  static const MotionType STOPED = Obstacle_MotionType_STOPED;
  static inline bool MotionType_IsValid(int value) {
    return Obstacle_MotionType_IsValid(value);
  }
  static const MotionType MotionType_MIN =
    Obstacle_MotionType_MotionType_MIN;
  static const MotionType MotionType_MAX =
    Obstacle_MotionType_MotionType_MAX;
  static const int MotionType_ARRAYSIZE =
    Obstacle_MotionType_MotionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MotionType_descriptor() {
    return Obstacle_MotionType_descriptor();
  }
  static inline const ::std::string& MotionType_Name(MotionType value) {
    return Obstacle_MotionType_Name(value);
  }
  static inline bool MotionType_Parse(const ::std::string& name,
      MotionType* value) {
    return Obstacle_MotionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // optional uint32 device_code = 2;
  inline bool has_device_code() const;
  inline void clear_device_code();
  static const int kDeviceCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 device_code() const;
  inline void set_device_code(::google::protobuf::uint32 value);

  // optional int32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .Proto_msg.Point3 anchor = 4;
  inline bool has_anchor() const;
  inline void clear_anchor();
  static const int kAnchorFieldNumber = 4;
  inline const ::Proto_msg::Point3& anchor() const;
  inline ::Proto_msg::Point3* mutable_anchor();
  inline ::Proto_msg::Point3* release_anchor();
  inline void set_allocated_anchor(::Proto_msg::Point3* anchor);

  // optional .Proto_msg.Point3 geo_center = 5;
  inline bool has_geo_center() const;
  inline void clear_geo_center();
  static const int kGeoCenterFieldNumber = 5;
  inline const ::Proto_msg::Point3& geo_center() const;
  inline ::Proto_msg::Point3* mutable_geo_center();
  inline ::Proto_msg::Point3* release_geo_center();
  inline void set_allocated_geo_center(::Proto_msg::Point3* geo_center);

  // optional .Proto_msg.Point3 geo_size = 6;
  inline bool has_geo_size() const;
  inline void clear_geo_size();
  static const int kGeoSizeFieldNumber = 6;
  inline const ::Proto_msg::Point3& geo_size() const;
  inline ::Proto_msg::Point3* mutable_geo_size();
  inline ::Proto_msg::Point3* release_geo_size();
  inline void set_allocated_geo_size(::Proto_msg::Point3* geo_size);

  // optional .Proto_msg.Point3 geo_direction = 7;
  inline bool has_geo_direction() const;
  inline void clear_geo_direction();
  static const int kGeoDirectionFieldNumber = 7;
  inline const ::Proto_msg::Point3& geo_direction() const;
  inline ::Proto_msg::Point3* mutable_geo_direction();
  inline ::Proto_msg::Point3* release_geo_direction();
  inline void set_allocated_geo_direction(::Proto_msg::Point3* geo_direction);

  // repeated .Proto_msg.Point3 polygon = 8;
  inline int polygon_size() const;
  inline void clear_polygon();
  static const int kPolygonFieldNumber = 8;
  inline const ::Proto_msg::Point3& polygon(int index) const;
  inline ::Proto_msg::Point3* mutable_polygon(int index);
  inline ::Proto_msg::Point3* add_polygon();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto_msg::Point3 >&
      polygon() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto_msg::Point3 >*
      mutable_polygon();

  // optional float detect_confidence = 9;
  inline bool has_detect_confidence() const;
  inline void clear_detect_confidence();
  static const int kDetectConfidenceFieldNumber = 9;
  inline float detect_confidence() const;
  inline void set_detect_confidence(float value);

  // optional .Proto_msg.Point3 nearest_point = 10;
  inline bool has_nearest_point() const;
  inline void clear_nearest_point();
  static const int kNearestPointFieldNumber = 10;
  inline const ::Proto_msg::Point3& nearest_point() const;
  inline ::Proto_msg::Point3* mutable_nearest_point();
  inline ::Proto_msg::Point3* release_nearest_point();
  inline void set_allocated_nearest_point(::Proto_msg::Point3* nearest_point);

  // optional .Proto_msg.Point3 left_point = 11;
  inline bool has_left_point() const;
  inline void clear_left_point();
  static const int kLeftPointFieldNumber = 11;
  inline const ::Proto_msg::Point3& left_point() const;
  inline ::Proto_msg::Point3* mutable_left_point();
  inline ::Proto_msg::Point3* release_left_point();
  inline void set_allocated_left_point(::Proto_msg::Point3* left_point);

  // optional .Proto_msg.Point3 right_point = 12;
  inline bool has_right_point() const;
  inline void clear_right_point();
  static const int kRightPointFieldNumber = 12;
  inline const ::Proto_msg::Point3& right_point() const;
  inline ::Proto_msg::Point3* mutable_right_point();
  inline ::Proto_msg::Point3* release_right_point();
  inline void set_allocated_right_point(::Proto_msg::Point3* right_point);

  // optional float distance = 13;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 13;
  inline float distance() const;
  inline void set_distance(float value);

  // optional float yaw = 14;
  inline bool has_yaw() const;
  inline void clear_yaw();
  static const int kYawFieldNumber = 14;
  inline float yaw() const;
  inline void set_yaw(float value);

  // optional int32 point_num = 15;
  inline bool has_point_num() const;
  inline void clear_point_num();
  static const int kPointNumFieldNumber = 15;
  inline ::google::protobuf::int32 point_num() const;
  inline void set_point_num(::google::protobuf::int32 value);

  // optional .Proto_msg.Obstacle.Type type = 16;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 16;
  inline ::Proto_msg::Obstacle_Type type() const;
  inline void set_type(::Proto_msg::Obstacle_Type value);

  // optional float type_confidence = 17;
  inline bool has_type_confidence() const;
  inline void clear_type_confidence();
  static const int kTypeConfidenceFieldNumber = 17;
  inline float type_confidence() const;
  inline void set_type_confidence(float value);

  // repeated float latent_types = 18;
  inline int latent_types_size() const;
  inline void clear_latent_types();
  static const int kLatentTypesFieldNumber = 18;
  inline float latent_types(int index) const;
  inline void set_latent_types(int index, float value);
  inline void add_latent_types(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      latent_types() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_latent_types();

  // optional .Proto_msg.Obstacle.MotionType motion_state = 19;
  inline bool has_motion_state() const;
  inline void clear_motion_state();
  static const int kMotionStateFieldNumber = 19;
  inline ::Proto_msg::Obstacle_MotionType motion_state() const;
  inline void set_motion_state(::Proto_msg::Obstacle_MotionType value);

  // optional bool is_track_converged = 20;
  inline bool has_is_track_converged() const;
  inline void clear_is_track_converged();
  static const int kIsTrackConvergedFieldNumber = 20;
  inline bool is_track_converged() const;
  inline void set_is_track_converged(bool value);

  // optional int32 tracker_id = 21;
  inline bool has_tracker_id() const;
  inline void clear_tracker_id();
  static const int kTrackerIdFieldNumber = 21;
  inline ::google::protobuf::int32 tracker_id() const;
  inline void set_tracker_id(::google::protobuf::int32 value);

  // optional .Proto_msg.Point3 velocity = 22;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 22;
  inline const ::Proto_msg::Point3& velocity() const;
  inline ::Proto_msg::Point3* mutable_velocity();
  inline ::Proto_msg::Point3* release_velocity();
  inline void set_allocated_velocity(::Proto_msg::Point3* velocity);

  // repeated float velocity_cov = 23;
  inline int velocity_cov_size() const;
  inline void clear_velocity_cov();
  static const int kVelocityCovFieldNumber = 23;
  inline float velocity_cov(int index) const;
  inline void set_velocity_cov(int index, float value);
  inline void add_velocity_cov(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      velocity_cov() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_velocity_cov();

  // optional float velocity_uncertainty = 24;
  inline bool has_velocity_uncertainty() const;
  inline void clear_velocity_uncertainty();
  static const int kVelocityUncertaintyFieldNumber = 24;
  inline float velocity_uncertainty() const;
  inline void set_velocity_uncertainty(float value);

  // optional .Proto_msg.Point3 ave_velocity = 25;
  inline bool has_ave_velocity() const;
  inline void clear_ave_velocity();
  static const int kAveVelocityFieldNumber = 25;
  inline const ::Proto_msg::Point3& ave_velocity() const;
  inline ::Proto_msg::Point3* mutable_ave_velocity();
  inline ::Proto_msg::Point3* release_ave_velocity();
  inline void set_allocated_ave_velocity(::Proto_msg::Point3* ave_velocity);

  // optional .Proto_msg.Point3 acceleration = 26;
  inline bool has_acceleration() const;
  inline void clear_acceleration();
  static const int kAccelerationFieldNumber = 26;
  inline const ::Proto_msg::Point3& acceleration() const;
  inline ::Proto_msg::Point3* mutable_acceleration();
  inline ::Proto_msg::Point3* release_acceleration();
  inline void set_allocated_acceleration(::Proto_msg::Point3* acceleration);

  // repeated float acceleration_cov = 27;
  inline int acceleration_cov_size() const;
  inline void clear_acceleration_cov();
  static const int kAccelerationCovFieldNumber = 27;
  inline float acceleration_cov(int index) const;
  inline void set_acceleration_cov(int index, float value);
  inline void add_acceleration_cov(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      acceleration_cov() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_acceleration_cov();

  // optional float acceleration_uncertainty = 28;
  inline bool has_acceleration_uncertainty() const;
  inline void clear_acceleration_uncertainty();
  static const int kAccelerationUncertaintyFieldNumber = 28;
  inline float acceleration_uncertainty() const;
  inline void set_acceleration_uncertainty(float value);

  // optional .Proto_msg.Point3 ave_acceleration = 29;
  inline bool has_ave_acceleration() const;
  inline void clear_ave_acceleration();
  static const int kAveAccelerationFieldNumber = 29;
  inline const ::Proto_msg::Point3& ave_acceleration() const;
  inline ::Proto_msg::Point3* mutable_ave_acceleration();
  inline ::Proto_msg::Point3* release_ave_acceleration();
  inline void set_allocated_ave_acceleration(::Proto_msg::Point3* ave_acceleration);

  // optional float angle_velocity = 30;
  inline bool has_angle_velocity() const;
  inline void clear_angle_velocity();
  static const int kAngleVelocityFieldNumber = 30;
  inline float angle_velocity() const;
  inline void set_angle_velocity(float value);

  // optional float angle_velocity_cov = 31;
  inline bool has_angle_velocity_cov() const;
  inline void clear_angle_velocity_cov();
  static const int kAngleVelocityCovFieldNumber = 31;
  inline float angle_velocity_cov() const;
  inline void set_angle_velocity_cov(float value);

  // optional float angle_velocity_uncertainty = 32;
  inline bool has_angle_velocity_uncertainty() const;
  inline void clear_angle_velocity_uncertainty();
  static const int kAngleVelocityUncertaintyFieldNumber = 32;
  inline float angle_velocity_uncertainty() const;
  inline void set_angle_velocity_uncertainty(float value);

  // optional float ave_angle_velocity = 33;
  inline bool has_ave_angle_velocity() const;
  inline void clear_ave_angle_velocity();
  static const int kAveAngleVelocityFieldNumber = 33;
  inline float ave_angle_velocity() const;
  inline void set_ave_angle_velocity(float value);

  // optional float asso_quality = 34;
  inline bool has_asso_quality() const;
  inline void clear_asso_quality();
  static const int kAssoQualityFieldNumber = 34;
  inline float asso_quality() const;
  inline void set_asso_quality(float value);

  // optional float tracker_quality = 35;
  inline bool has_tracker_quality() const;
  inline void clear_tracker_quality();
  static const int kTrackerQualityFieldNumber = 35;
  inline float tracker_quality() const;
  inline void set_tracker_quality(float value);

  // optional double tracking_time = 36;
  inline bool has_tracking_time() const;
  inline void clear_tracking_time();
  static const int kTrackingTimeFieldNumber = 36;
  inline double tracking_time() const;
  inline void set_tracking_time(double value);

  // @@protoc_insertion_point(class_scope:Proto_msg.Obstacle)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_device_code();
  inline void clear_has_device_code();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_anchor();
  inline void clear_has_anchor();
  inline void set_has_geo_center();
  inline void clear_has_geo_center();
  inline void set_has_geo_size();
  inline void clear_has_geo_size();
  inline void set_has_geo_direction();
  inline void clear_has_geo_direction();
  inline void set_has_detect_confidence();
  inline void clear_has_detect_confidence();
  inline void set_has_nearest_point();
  inline void clear_has_nearest_point();
  inline void set_has_left_point();
  inline void clear_has_left_point();
  inline void set_has_right_point();
  inline void clear_has_right_point();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_yaw();
  inline void clear_has_yaw();
  inline void set_has_point_num();
  inline void clear_has_point_num();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_type_confidence();
  inline void clear_has_type_confidence();
  inline void set_has_motion_state();
  inline void clear_has_motion_state();
  inline void set_has_is_track_converged();
  inline void clear_has_is_track_converged();
  inline void set_has_tracker_id();
  inline void clear_has_tracker_id();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_velocity_uncertainty();
  inline void clear_has_velocity_uncertainty();
  inline void set_has_ave_velocity();
  inline void clear_has_ave_velocity();
  inline void set_has_acceleration();
  inline void clear_has_acceleration();
  inline void set_has_acceleration_uncertainty();
  inline void clear_has_acceleration_uncertainty();
  inline void set_has_ave_acceleration();
  inline void clear_has_ave_acceleration();
  inline void set_has_angle_velocity();
  inline void clear_has_angle_velocity();
  inline void set_has_angle_velocity_cov();
  inline void clear_has_angle_velocity_cov();
  inline void set_has_angle_velocity_uncertainty();
  inline void clear_has_angle_velocity_uncertainty();
  inline void set_has_ave_angle_velocity();
  inline void clear_has_ave_angle_velocity();
  inline void set_has_asso_quality();
  inline void clear_has_asso_quality();
  inline void set_has_tracker_quality();
  inline void clear_has_tracker_quality();
  inline void set_has_tracking_time();
  inline void clear_has_tracking_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  double timestamp_;
  ::google::protobuf::uint32 device_code_;
  ::google::protobuf::int32 id_;
  ::Proto_msg::Point3* anchor_;
  ::Proto_msg::Point3* geo_center_;
  ::Proto_msg::Point3* geo_size_;
  ::Proto_msg::Point3* geo_direction_;
  ::google::protobuf::RepeatedPtrField< ::Proto_msg::Point3 > polygon_;
  ::Proto_msg::Point3* nearest_point_;
  ::Proto_msg::Point3* left_point_;
  float detect_confidence_;
  float distance_;
  ::Proto_msg::Point3* right_point_;
  float yaw_;
  ::google::protobuf::int32 point_num_;
  int type_;
  float type_confidence_;
  ::google::protobuf::RepeatedField< float > latent_types_;
  int motion_state_;
  bool is_track_converged_;
  ::Proto_msg::Point3* velocity_;
  ::google::protobuf::int32 tracker_id_;
  float velocity_uncertainty_;
  ::google::protobuf::RepeatedField< float > velocity_cov_;
  ::Proto_msg::Point3* ave_velocity_;
  ::Proto_msg::Point3* acceleration_;
  ::google::protobuf::RepeatedField< float > acceleration_cov_;
  ::Proto_msg::Point3* ave_acceleration_;
  float acceleration_uncertainty_;
  float angle_velocity_;
  float angle_velocity_cov_;
  float angle_velocity_uncertainty_;
  float ave_angle_velocity_;
  float asso_quality_;
  double tracking_time_;
  float tracker_quality_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_Proto_5fmsg_2ePercept_2eproto();
  friend void protobuf_AssignDesc_Proto_5fmsg_2ePercept_2eproto();
  friend void protobuf_ShutdownFile_Proto_5fmsg_2ePercept_2eproto();

  void InitAsDefaultInstance();
  static Obstacle* default_instance_;
};
// -------------------------------------------------------------------

class FreeSpaces : public ::google::protobuf::Message {
 public:
  FreeSpaces();
  virtual ~FreeSpaces();

  FreeSpaces(const FreeSpaces& from);

  inline FreeSpaces& operator=(const FreeSpaces& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FreeSpaces& default_instance();

  void Swap(FreeSpaces* other);

  // implements Message ----------------------------------------------

  FreeSpaces* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FreeSpaces& from);
  void MergeFrom(const FreeSpaces& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // optional uint32 seq = 2;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 2;
  inline ::google::protobuf::uint32 seq() const;
  inline void set_seq(::google::protobuf::uint32 value);

  // optional string parent_frame_id = 3;
  inline bool has_parent_frame_id() const;
  inline void clear_parent_frame_id();
  static const int kParentFrameIdFieldNumber = 3;
  inline const ::std::string& parent_frame_id() const;
  inline void set_parent_frame_id(const ::std::string& value);
  inline void set_parent_frame_id(const char* value);
  inline void set_parent_frame_id(const char* value, size_t size);
  inline ::std::string* mutable_parent_frame_id();
  inline ::std::string* release_parent_frame_id();
  inline void set_allocated_parent_frame_id(::std::string* parent_frame_id);

  // optional string frame_id = 4;
  inline bool has_frame_id() const;
  inline void clear_frame_id();
  static const int kFrameIdFieldNumber = 4;
  inline const ::std::string& frame_id() const;
  inline void set_frame_id(const ::std::string& value);
  inline void set_frame_id(const char* value);
  inline void set_frame_id(const char* value, size_t size);
  inline ::std::string* mutable_frame_id();
  inline ::std::string* release_frame_id();
  inline void set_allocated_frame_id(::std::string* frame_id);

  // repeated .Proto_msg.FreeSpace freeSpaces = 5;
  inline int freespaces_size() const;
  inline void clear_freespaces();
  static const int kFreeSpacesFieldNumber = 5;
  inline const ::Proto_msg::FreeSpace& freespaces(int index) const;
  inline ::Proto_msg::FreeSpace* mutable_freespaces(int index);
  inline ::Proto_msg::FreeSpace* add_freespaces();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto_msg::FreeSpace >&
      freespaces() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto_msg::FreeSpace >*
      mutable_freespaces();

  // @@protoc_insertion_point(class_scope:Proto_msg.FreeSpaces)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_parent_frame_id();
  inline void clear_has_parent_frame_id();
  inline void set_has_frame_id();
  inline void clear_has_frame_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double timestamp_;
  ::std::string* parent_frame_id_;
  ::std::string* frame_id_;
  ::google::protobuf::RepeatedPtrField< ::Proto_msg::FreeSpace > freespaces_;
  ::google::protobuf::uint32 seq_;
  friend void  protobuf_AddDesc_Proto_5fmsg_2ePercept_2eproto();
  friend void protobuf_AssignDesc_Proto_5fmsg_2ePercept_2eproto();
  friend void protobuf_ShutdownFile_Proto_5fmsg_2ePercept_2eproto();

  void InitAsDefaultInstance();
  static FreeSpaces* default_instance_;
};
// -------------------------------------------------------------------

class Obstacles : public ::google::protobuf::Message {
 public:
  Obstacles();
  virtual ~Obstacles();

  Obstacles(const Obstacles& from);

  inline Obstacles& operator=(const Obstacles& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Obstacles& default_instance();

  void Swap(Obstacles* other);

  // implements Message ----------------------------------------------

  Obstacles* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Obstacles& from);
  void MergeFrom(const Obstacles& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // optional uint32 seq = 2;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 2;
  inline ::google::protobuf::uint32 seq() const;
  inline void set_seq(::google::protobuf::uint32 value);

  // optional string parent_frame_id = 3;
  inline bool has_parent_frame_id() const;
  inline void clear_parent_frame_id();
  static const int kParentFrameIdFieldNumber = 3;
  inline const ::std::string& parent_frame_id() const;
  inline void set_parent_frame_id(const ::std::string& value);
  inline void set_parent_frame_id(const char* value);
  inline void set_parent_frame_id(const char* value, size_t size);
  inline ::std::string* mutable_parent_frame_id();
  inline ::std::string* release_parent_frame_id();
  inline void set_allocated_parent_frame_id(::std::string* parent_frame_id);

  // optional string frame_id = 4;
  inline bool has_frame_id() const;
  inline void clear_frame_id();
  static const int kFrameIdFieldNumber = 4;
  inline const ::std::string& frame_id() const;
  inline void set_frame_id(const ::std::string& value);
  inline void set_frame_id(const char* value);
  inline void set_frame_id(const char* value, size_t size);
  inline ::std::string* mutable_frame_id();
  inline ::std::string* release_frame_id();
  inline void set_allocated_frame_id(::std::string* frame_id);

  // repeated .Proto_msg.Obstacle obstacles = 5;
  inline int obstacles_size() const;
  inline void clear_obstacles();
  static const int kObstaclesFieldNumber = 5;
  inline const ::Proto_msg::Obstacle& obstacles(int index) const;
  inline ::Proto_msg::Obstacle* mutable_obstacles(int index);
  inline ::Proto_msg::Obstacle* add_obstacles();
  inline const ::google::protobuf::RepeatedPtrField< ::Proto_msg::Obstacle >&
      obstacles() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proto_msg::Obstacle >*
      mutable_obstacles();

  // @@protoc_insertion_point(class_scope:Proto_msg.Obstacles)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_parent_frame_id();
  inline void clear_has_parent_frame_id();
  inline void set_has_frame_id();
  inline void clear_has_frame_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double timestamp_;
  ::std::string* parent_frame_id_;
  ::std::string* frame_id_;
  ::google::protobuf::RepeatedPtrField< ::Proto_msg::Obstacle > obstacles_;
  ::google::protobuf::uint32 seq_;
  friend void  protobuf_AddDesc_Proto_5fmsg_2ePercept_2eproto();
  friend void protobuf_AssignDesc_Proto_5fmsg_2ePercept_2eproto();
  friend void protobuf_ShutdownFile_Proto_5fmsg_2ePercept_2eproto();

  void InitAsDefaultInstance();
  static Obstacles* default_instance_;
};
// ===================================================================


// ===================================================================

// Point3

// optional float x = 1;
inline bool Point3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Point3::x() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Point3.x)
  return x_;
}
inline void Point3::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Point3.x)
}

// optional float y = 2;
inline bool Point3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Point3::y() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Point3.y)
  return y_;
}
inline void Point3::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Point3.y)
}

// optional float z = 3;
inline bool Point3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Point3::z() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Point3.z)
  return z_;
}
inline void Point3::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Point3.z)
}

// -------------------------------------------------------------------

// FreeSpace

// optional double timestamp = 1;
inline bool FreeSpace::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FreeSpace::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FreeSpace::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FreeSpace::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double FreeSpace::timestamp() const {
  // @@protoc_insertion_point(field_get:Proto_msg.FreeSpace.timestamp)
  return timestamp_;
}
inline void FreeSpace::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.FreeSpace.timestamp)
}

// optional uint32 device_code = 2;
inline bool FreeSpace::has_device_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FreeSpace::set_has_device_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FreeSpace::clear_has_device_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FreeSpace::clear_device_code() {
  device_code_ = 0u;
  clear_has_device_code();
}
inline ::google::protobuf::uint32 FreeSpace::device_code() const {
  // @@protoc_insertion_point(field_get:Proto_msg.FreeSpace.device_code)
  return device_code_;
}
inline void FreeSpace::set_device_code(::google::protobuf::uint32 value) {
  set_has_device_code();
  device_code_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.FreeSpace.device_code)
}

// optional float distance = 3;
inline bool FreeSpace::has_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FreeSpace::set_has_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FreeSpace::clear_has_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FreeSpace::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline float FreeSpace::distance() const {
  // @@protoc_insertion_point(field_get:Proto_msg.FreeSpace.distance)
  return distance_;
}
inline void FreeSpace::set_distance(float value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.FreeSpace.distance)
}

// optional float yaw_angle = 4;
inline bool FreeSpace::has_yaw_angle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FreeSpace::set_has_yaw_angle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FreeSpace::clear_has_yaw_angle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FreeSpace::clear_yaw_angle() {
  yaw_angle_ = 0;
  clear_has_yaw_angle();
}
inline float FreeSpace::yaw_angle() const {
  // @@protoc_insertion_point(field_get:Proto_msg.FreeSpace.yaw_angle)
  return yaw_angle_;
}
inline void FreeSpace::set_yaw_angle(float value) {
  set_has_yaw_angle();
  yaw_angle_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.FreeSpace.yaw_angle)
}

// optional float free_prob = 5;
inline bool FreeSpace::has_free_prob() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FreeSpace::set_has_free_prob() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FreeSpace::clear_has_free_prob() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FreeSpace::clear_free_prob() {
  free_prob_ = 0;
  clear_has_free_prob();
}
inline float FreeSpace::free_prob() const {
  // @@protoc_insertion_point(field_get:Proto_msg.FreeSpace.free_prob)
  return free_prob_;
}
inline void FreeSpace::set_free_prob(float value) {
  set_has_free_prob();
  free_prob_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.FreeSpace.free_prob)
}

// -------------------------------------------------------------------

// Obstacle

// optional double timestamp = 1;
inline bool Obstacle::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Obstacle::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Obstacle::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Obstacle::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double Obstacle::timestamp() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.timestamp)
  return timestamp_;
}
inline void Obstacle::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.timestamp)
}

// optional uint32 device_code = 2;
inline bool Obstacle::has_device_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Obstacle::set_has_device_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Obstacle::clear_has_device_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Obstacle::clear_device_code() {
  device_code_ = 0u;
  clear_has_device_code();
}
inline ::google::protobuf::uint32 Obstacle::device_code() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.device_code)
  return device_code_;
}
inline void Obstacle::set_device_code(::google::protobuf::uint32 value) {
  set_has_device_code();
  device_code_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.device_code)
}

// optional int32 id = 3;
inline bool Obstacle::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Obstacle::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Obstacle::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Obstacle::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Obstacle::id() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.id)
  return id_;
}
inline void Obstacle::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.id)
}

// optional .Proto_msg.Point3 anchor = 4;
inline bool Obstacle::has_anchor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Obstacle::set_has_anchor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Obstacle::clear_has_anchor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Obstacle::clear_anchor() {
  if (anchor_ != NULL) anchor_->::Proto_msg::Point3::Clear();
  clear_has_anchor();
}
inline const ::Proto_msg::Point3& Obstacle::anchor() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.anchor)
  return anchor_ != NULL ? *anchor_ : *default_instance_->anchor_;
}
inline ::Proto_msg::Point3* Obstacle::mutable_anchor() {
  set_has_anchor();
  if (anchor_ == NULL) anchor_ = new ::Proto_msg::Point3;
  // @@protoc_insertion_point(field_mutable:Proto_msg.Obstacle.anchor)
  return anchor_;
}
inline ::Proto_msg::Point3* Obstacle::release_anchor() {
  clear_has_anchor();
  ::Proto_msg::Point3* temp = anchor_;
  anchor_ = NULL;
  return temp;
}
inline void Obstacle::set_allocated_anchor(::Proto_msg::Point3* anchor) {
  delete anchor_;
  anchor_ = anchor;
  if (anchor) {
    set_has_anchor();
  } else {
    clear_has_anchor();
  }
  // @@protoc_insertion_point(field_set_allocated:Proto_msg.Obstacle.anchor)
}

// optional .Proto_msg.Point3 geo_center = 5;
inline bool Obstacle::has_geo_center() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Obstacle::set_has_geo_center() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Obstacle::clear_has_geo_center() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Obstacle::clear_geo_center() {
  if (geo_center_ != NULL) geo_center_->::Proto_msg::Point3::Clear();
  clear_has_geo_center();
}
inline const ::Proto_msg::Point3& Obstacle::geo_center() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.geo_center)
  return geo_center_ != NULL ? *geo_center_ : *default_instance_->geo_center_;
}
inline ::Proto_msg::Point3* Obstacle::mutable_geo_center() {
  set_has_geo_center();
  if (geo_center_ == NULL) geo_center_ = new ::Proto_msg::Point3;
  // @@protoc_insertion_point(field_mutable:Proto_msg.Obstacle.geo_center)
  return geo_center_;
}
inline ::Proto_msg::Point3* Obstacle::release_geo_center() {
  clear_has_geo_center();
  ::Proto_msg::Point3* temp = geo_center_;
  geo_center_ = NULL;
  return temp;
}
inline void Obstacle::set_allocated_geo_center(::Proto_msg::Point3* geo_center) {
  delete geo_center_;
  geo_center_ = geo_center;
  if (geo_center) {
    set_has_geo_center();
  } else {
    clear_has_geo_center();
  }
  // @@protoc_insertion_point(field_set_allocated:Proto_msg.Obstacle.geo_center)
}

// optional .Proto_msg.Point3 geo_size = 6;
inline bool Obstacle::has_geo_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Obstacle::set_has_geo_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Obstacle::clear_has_geo_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Obstacle::clear_geo_size() {
  if (geo_size_ != NULL) geo_size_->::Proto_msg::Point3::Clear();
  clear_has_geo_size();
}
inline const ::Proto_msg::Point3& Obstacle::geo_size() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.geo_size)
  return geo_size_ != NULL ? *geo_size_ : *default_instance_->geo_size_;
}
inline ::Proto_msg::Point3* Obstacle::mutable_geo_size() {
  set_has_geo_size();
  if (geo_size_ == NULL) geo_size_ = new ::Proto_msg::Point3;
  // @@protoc_insertion_point(field_mutable:Proto_msg.Obstacle.geo_size)
  return geo_size_;
}
inline ::Proto_msg::Point3* Obstacle::release_geo_size() {
  clear_has_geo_size();
  ::Proto_msg::Point3* temp = geo_size_;
  geo_size_ = NULL;
  return temp;
}
inline void Obstacle::set_allocated_geo_size(::Proto_msg::Point3* geo_size) {
  delete geo_size_;
  geo_size_ = geo_size;
  if (geo_size) {
    set_has_geo_size();
  } else {
    clear_has_geo_size();
  }
  // @@protoc_insertion_point(field_set_allocated:Proto_msg.Obstacle.geo_size)
}

// optional .Proto_msg.Point3 geo_direction = 7;
inline bool Obstacle::has_geo_direction() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Obstacle::set_has_geo_direction() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Obstacle::clear_has_geo_direction() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Obstacle::clear_geo_direction() {
  if (geo_direction_ != NULL) geo_direction_->::Proto_msg::Point3::Clear();
  clear_has_geo_direction();
}
inline const ::Proto_msg::Point3& Obstacle::geo_direction() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.geo_direction)
  return geo_direction_ != NULL ? *geo_direction_ : *default_instance_->geo_direction_;
}
inline ::Proto_msg::Point3* Obstacle::mutable_geo_direction() {
  set_has_geo_direction();
  if (geo_direction_ == NULL) geo_direction_ = new ::Proto_msg::Point3;
  // @@protoc_insertion_point(field_mutable:Proto_msg.Obstacle.geo_direction)
  return geo_direction_;
}
inline ::Proto_msg::Point3* Obstacle::release_geo_direction() {
  clear_has_geo_direction();
  ::Proto_msg::Point3* temp = geo_direction_;
  geo_direction_ = NULL;
  return temp;
}
inline void Obstacle::set_allocated_geo_direction(::Proto_msg::Point3* geo_direction) {
  delete geo_direction_;
  geo_direction_ = geo_direction;
  if (geo_direction) {
    set_has_geo_direction();
  } else {
    clear_has_geo_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:Proto_msg.Obstacle.geo_direction)
}

// repeated .Proto_msg.Point3 polygon = 8;
inline int Obstacle::polygon_size() const {
  return polygon_.size();
}
inline void Obstacle::clear_polygon() {
  polygon_.Clear();
}
inline const ::Proto_msg::Point3& Obstacle::polygon(int index) const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.polygon)
  return polygon_.Get(index);
}
inline ::Proto_msg::Point3* Obstacle::mutable_polygon(int index) {
  // @@protoc_insertion_point(field_mutable:Proto_msg.Obstacle.polygon)
  return polygon_.Mutable(index);
}
inline ::Proto_msg::Point3* Obstacle::add_polygon() {
  // @@protoc_insertion_point(field_add:Proto_msg.Obstacle.polygon)
  return polygon_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto_msg::Point3 >&
Obstacle::polygon() const {
  // @@protoc_insertion_point(field_list:Proto_msg.Obstacle.polygon)
  return polygon_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto_msg::Point3 >*
Obstacle::mutable_polygon() {
  // @@protoc_insertion_point(field_mutable_list:Proto_msg.Obstacle.polygon)
  return &polygon_;
}

// optional float detect_confidence = 9;
inline bool Obstacle::has_detect_confidence() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Obstacle::set_has_detect_confidence() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Obstacle::clear_has_detect_confidence() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Obstacle::clear_detect_confidence() {
  detect_confidence_ = 0;
  clear_has_detect_confidence();
}
inline float Obstacle::detect_confidence() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.detect_confidence)
  return detect_confidence_;
}
inline void Obstacle::set_detect_confidence(float value) {
  set_has_detect_confidence();
  detect_confidence_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.detect_confidence)
}

// optional .Proto_msg.Point3 nearest_point = 10;
inline bool Obstacle::has_nearest_point() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Obstacle::set_has_nearest_point() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Obstacle::clear_has_nearest_point() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Obstacle::clear_nearest_point() {
  if (nearest_point_ != NULL) nearest_point_->::Proto_msg::Point3::Clear();
  clear_has_nearest_point();
}
inline const ::Proto_msg::Point3& Obstacle::nearest_point() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.nearest_point)
  return nearest_point_ != NULL ? *nearest_point_ : *default_instance_->nearest_point_;
}
inline ::Proto_msg::Point3* Obstacle::mutable_nearest_point() {
  set_has_nearest_point();
  if (nearest_point_ == NULL) nearest_point_ = new ::Proto_msg::Point3;
  // @@protoc_insertion_point(field_mutable:Proto_msg.Obstacle.nearest_point)
  return nearest_point_;
}
inline ::Proto_msg::Point3* Obstacle::release_nearest_point() {
  clear_has_nearest_point();
  ::Proto_msg::Point3* temp = nearest_point_;
  nearest_point_ = NULL;
  return temp;
}
inline void Obstacle::set_allocated_nearest_point(::Proto_msg::Point3* nearest_point) {
  delete nearest_point_;
  nearest_point_ = nearest_point;
  if (nearest_point) {
    set_has_nearest_point();
  } else {
    clear_has_nearest_point();
  }
  // @@protoc_insertion_point(field_set_allocated:Proto_msg.Obstacle.nearest_point)
}

// optional .Proto_msg.Point3 left_point = 11;
inline bool Obstacle::has_left_point() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Obstacle::set_has_left_point() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Obstacle::clear_has_left_point() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Obstacle::clear_left_point() {
  if (left_point_ != NULL) left_point_->::Proto_msg::Point3::Clear();
  clear_has_left_point();
}
inline const ::Proto_msg::Point3& Obstacle::left_point() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.left_point)
  return left_point_ != NULL ? *left_point_ : *default_instance_->left_point_;
}
inline ::Proto_msg::Point3* Obstacle::mutable_left_point() {
  set_has_left_point();
  if (left_point_ == NULL) left_point_ = new ::Proto_msg::Point3;
  // @@protoc_insertion_point(field_mutable:Proto_msg.Obstacle.left_point)
  return left_point_;
}
inline ::Proto_msg::Point3* Obstacle::release_left_point() {
  clear_has_left_point();
  ::Proto_msg::Point3* temp = left_point_;
  left_point_ = NULL;
  return temp;
}
inline void Obstacle::set_allocated_left_point(::Proto_msg::Point3* left_point) {
  delete left_point_;
  left_point_ = left_point;
  if (left_point) {
    set_has_left_point();
  } else {
    clear_has_left_point();
  }
  // @@protoc_insertion_point(field_set_allocated:Proto_msg.Obstacle.left_point)
}

// optional .Proto_msg.Point3 right_point = 12;
inline bool Obstacle::has_right_point() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Obstacle::set_has_right_point() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Obstacle::clear_has_right_point() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Obstacle::clear_right_point() {
  if (right_point_ != NULL) right_point_->::Proto_msg::Point3::Clear();
  clear_has_right_point();
}
inline const ::Proto_msg::Point3& Obstacle::right_point() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.right_point)
  return right_point_ != NULL ? *right_point_ : *default_instance_->right_point_;
}
inline ::Proto_msg::Point3* Obstacle::mutable_right_point() {
  set_has_right_point();
  if (right_point_ == NULL) right_point_ = new ::Proto_msg::Point3;
  // @@protoc_insertion_point(field_mutable:Proto_msg.Obstacle.right_point)
  return right_point_;
}
inline ::Proto_msg::Point3* Obstacle::release_right_point() {
  clear_has_right_point();
  ::Proto_msg::Point3* temp = right_point_;
  right_point_ = NULL;
  return temp;
}
inline void Obstacle::set_allocated_right_point(::Proto_msg::Point3* right_point) {
  delete right_point_;
  right_point_ = right_point;
  if (right_point) {
    set_has_right_point();
  } else {
    clear_has_right_point();
  }
  // @@protoc_insertion_point(field_set_allocated:Proto_msg.Obstacle.right_point)
}

// optional float distance = 13;
inline bool Obstacle::has_distance() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Obstacle::set_has_distance() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Obstacle::clear_has_distance() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Obstacle::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline float Obstacle::distance() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.distance)
  return distance_;
}
inline void Obstacle::set_distance(float value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.distance)
}

// optional float yaw = 14;
inline bool Obstacle::has_yaw() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Obstacle::set_has_yaw() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Obstacle::clear_has_yaw() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Obstacle::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float Obstacle::yaw() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.yaw)
  return yaw_;
}
inline void Obstacle::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.yaw)
}

// optional int32 point_num = 15;
inline bool Obstacle::has_point_num() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Obstacle::set_has_point_num() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Obstacle::clear_has_point_num() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Obstacle::clear_point_num() {
  point_num_ = 0;
  clear_has_point_num();
}
inline ::google::protobuf::int32 Obstacle::point_num() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.point_num)
  return point_num_;
}
inline void Obstacle::set_point_num(::google::protobuf::int32 value) {
  set_has_point_num();
  point_num_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.point_num)
}

// optional .Proto_msg.Obstacle.Type type = 16;
inline bool Obstacle::has_type() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Obstacle::set_has_type() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Obstacle::clear_has_type() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Obstacle::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Proto_msg::Obstacle_Type Obstacle::type() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.type)
  return static_cast< ::Proto_msg::Obstacle_Type >(type_);
}
inline void Obstacle::set_type(::Proto_msg::Obstacle_Type value) {
  assert(::Proto_msg::Obstacle_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.type)
}

// optional float type_confidence = 17;
inline bool Obstacle::has_type_confidence() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Obstacle::set_has_type_confidence() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Obstacle::clear_has_type_confidence() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Obstacle::clear_type_confidence() {
  type_confidence_ = 0;
  clear_has_type_confidence();
}
inline float Obstacle::type_confidence() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.type_confidence)
  return type_confidence_;
}
inline void Obstacle::set_type_confidence(float value) {
  set_has_type_confidence();
  type_confidence_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.type_confidence)
}

// repeated float latent_types = 18;
inline int Obstacle::latent_types_size() const {
  return latent_types_.size();
}
inline void Obstacle::clear_latent_types() {
  latent_types_.Clear();
}
inline float Obstacle::latent_types(int index) const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.latent_types)
  return latent_types_.Get(index);
}
inline void Obstacle::set_latent_types(int index, float value) {
  latent_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.latent_types)
}
inline void Obstacle::add_latent_types(float value) {
  latent_types_.Add(value);
  // @@protoc_insertion_point(field_add:Proto_msg.Obstacle.latent_types)
}
inline const ::google::protobuf::RepeatedField< float >&
Obstacle::latent_types() const {
  // @@protoc_insertion_point(field_list:Proto_msg.Obstacle.latent_types)
  return latent_types_;
}
inline ::google::protobuf::RepeatedField< float >*
Obstacle::mutable_latent_types() {
  // @@protoc_insertion_point(field_mutable_list:Proto_msg.Obstacle.latent_types)
  return &latent_types_;
}

// optional .Proto_msg.Obstacle.MotionType motion_state = 19;
inline bool Obstacle::has_motion_state() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Obstacle::set_has_motion_state() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Obstacle::clear_has_motion_state() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Obstacle::clear_motion_state() {
  motion_state_ = 0;
  clear_has_motion_state();
}
inline ::Proto_msg::Obstacle_MotionType Obstacle::motion_state() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.motion_state)
  return static_cast< ::Proto_msg::Obstacle_MotionType >(motion_state_);
}
inline void Obstacle::set_motion_state(::Proto_msg::Obstacle_MotionType value) {
  assert(::Proto_msg::Obstacle_MotionType_IsValid(value));
  set_has_motion_state();
  motion_state_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.motion_state)
}

// optional bool is_track_converged = 20;
inline bool Obstacle::has_is_track_converged() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Obstacle::set_has_is_track_converged() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Obstacle::clear_has_is_track_converged() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Obstacle::clear_is_track_converged() {
  is_track_converged_ = false;
  clear_has_is_track_converged();
}
inline bool Obstacle::is_track_converged() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.is_track_converged)
  return is_track_converged_;
}
inline void Obstacle::set_is_track_converged(bool value) {
  set_has_is_track_converged();
  is_track_converged_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.is_track_converged)
}

// optional int32 tracker_id = 21;
inline bool Obstacle::has_tracker_id() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Obstacle::set_has_tracker_id() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Obstacle::clear_has_tracker_id() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Obstacle::clear_tracker_id() {
  tracker_id_ = 0;
  clear_has_tracker_id();
}
inline ::google::protobuf::int32 Obstacle::tracker_id() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.tracker_id)
  return tracker_id_;
}
inline void Obstacle::set_tracker_id(::google::protobuf::int32 value) {
  set_has_tracker_id();
  tracker_id_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.tracker_id)
}

// optional .Proto_msg.Point3 velocity = 22;
inline bool Obstacle::has_velocity() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Obstacle::set_has_velocity() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Obstacle::clear_has_velocity() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Obstacle::clear_velocity() {
  if (velocity_ != NULL) velocity_->::Proto_msg::Point3::Clear();
  clear_has_velocity();
}
inline const ::Proto_msg::Point3& Obstacle::velocity() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.velocity)
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
inline ::Proto_msg::Point3* Obstacle::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) velocity_ = new ::Proto_msg::Point3;
  // @@protoc_insertion_point(field_mutable:Proto_msg.Obstacle.velocity)
  return velocity_;
}
inline ::Proto_msg::Point3* Obstacle::release_velocity() {
  clear_has_velocity();
  ::Proto_msg::Point3* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void Obstacle::set_allocated_velocity(::Proto_msg::Point3* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:Proto_msg.Obstacle.velocity)
}

// repeated float velocity_cov = 23;
inline int Obstacle::velocity_cov_size() const {
  return velocity_cov_.size();
}
inline void Obstacle::clear_velocity_cov() {
  velocity_cov_.Clear();
}
inline float Obstacle::velocity_cov(int index) const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.velocity_cov)
  return velocity_cov_.Get(index);
}
inline void Obstacle::set_velocity_cov(int index, float value) {
  velocity_cov_.Set(index, value);
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.velocity_cov)
}
inline void Obstacle::add_velocity_cov(float value) {
  velocity_cov_.Add(value);
  // @@protoc_insertion_point(field_add:Proto_msg.Obstacle.velocity_cov)
}
inline const ::google::protobuf::RepeatedField< float >&
Obstacle::velocity_cov() const {
  // @@protoc_insertion_point(field_list:Proto_msg.Obstacle.velocity_cov)
  return velocity_cov_;
}
inline ::google::protobuf::RepeatedField< float >*
Obstacle::mutable_velocity_cov() {
  // @@protoc_insertion_point(field_mutable_list:Proto_msg.Obstacle.velocity_cov)
  return &velocity_cov_;
}

// optional float velocity_uncertainty = 24;
inline bool Obstacle::has_velocity_uncertainty() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Obstacle::set_has_velocity_uncertainty() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Obstacle::clear_has_velocity_uncertainty() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Obstacle::clear_velocity_uncertainty() {
  velocity_uncertainty_ = 0;
  clear_has_velocity_uncertainty();
}
inline float Obstacle::velocity_uncertainty() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.velocity_uncertainty)
  return velocity_uncertainty_;
}
inline void Obstacle::set_velocity_uncertainty(float value) {
  set_has_velocity_uncertainty();
  velocity_uncertainty_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.velocity_uncertainty)
}

// optional .Proto_msg.Point3 ave_velocity = 25;
inline bool Obstacle::has_ave_velocity() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Obstacle::set_has_ave_velocity() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Obstacle::clear_has_ave_velocity() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Obstacle::clear_ave_velocity() {
  if (ave_velocity_ != NULL) ave_velocity_->::Proto_msg::Point3::Clear();
  clear_has_ave_velocity();
}
inline const ::Proto_msg::Point3& Obstacle::ave_velocity() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.ave_velocity)
  return ave_velocity_ != NULL ? *ave_velocity_ : *default_instance_->ave_velocity_;
}
inline ::Proto_msg::Point3* Obstacle::mutable_ave_velocity() {
  set_has_ave_velocity();
  if (ave_velocity_ == NULL) ave_velocity_ = new ::Proto_msg::Point3;
  // @@protoc_insertion_point(field_mutable:Proto_msg.Obstacle.ave_velocity)
  return ave_velocity_;
}
inline ::Proto_msg::Point3* Obstacle::release_ave_velocity() {
  clear_has_ave_velocity();
  ::Proto_msg::Point3* temp = ave_velocity_;
  ave_velocity_ = NULL;
  return temp;
}
inline void Obstacle::set_allocated_ave_velocity(::Proto_msg::Point3* ave_velocity) {
  delete ave_velocity_;
  ave_velocity_ = ave_velocity;
  if (ave_velocity) {
    set_has_ave_velocity();
  } else {
    clear_has_ave_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:Proto_msg.Obstacle.ave_velocity)
}

// optional .Proto_msg.Point3 acceleration = 26;
inline bool Obstacle::has_acceleration() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Obstacle::set_has_acceleration() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Obstacle::clear_has_acceleration() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Obstacle::clear_acceleration() {
  if (acceleration_ != NULL) acceleration_->::Proto_msg::Point3::Clear();
  clear_has_acceleration();
}
inline const ::Proto_msg::Point3& Obstacle::acceleration() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.acceleration)
  return acceleration_ != NULL ? *acceleration_ : *default_instance_->acceleration_;
}
inline ::Proto_msg::Point3* Obstacle::mutable_acceleration() {
  set_has_acceleration();
  if (acceleration_ == NULL) acceleration_ = new ::Proto_msg::Point3;
  // @@protoc_insertion_point(field_mutable:Proto_msg.Obstacle.acceleration)
  return acceleration_;
}
inline ::Proto_msg::Point3* Obstacle::release_acceleration() {
  clear_has_acceleration();
  ::Proto_msg::Point3* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline void Obstacle::set_allocated_acceleration(::Proto_msg::Point3* acceleration) {
  delete acceleration_;
  acceleration_ = acceleration;
  if (acceleration) {
    set_has_acceleration();
  } else {
    clear_has_acceleration();
  }
  // @@protoc_insertion_point(field_set_allocated:Proto_msg.Obstacle.acceleration)
}

// repeated float acceleration_cov = 27;
inline int Obstacle::acceleration_cov_size() const {
  return acceleration_cov_.size();
}
inline void Obstacle::clear_acceleration_cov() {
  acceleration_cov_.Clear();
}
inline float Obstacle::acceleration_cov(int index) const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.acceleration_cov)
  return acceleration_cov_.Get(index);
}
inline void Obstacle::set_acceleration_cov(int index, float value) {
  acceleration_cov_.Set(index, value);
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.acceleration_cov)
}
inline void Obstacle::add_acceleration_cov(float value) {
  acceleration_cov_.Add(value);
  // @@protoc_insertion_point(field_add:Proto_msg.Obstacle.acceleration_cov)
}
inline const ::google::protobuf::RepeatedField< float >&
Obstacle::acceleration_cov() const {
  // @@protoc_insertion_point(field_list:Proto_msg.Obstacle.acceleration_cov)
  return acceleration_cov_;
}
inline ::google::protobuf::RepeatedField< float >*
Obstacle::mutable_acceleration_cov() {
  // @@protoc_insertion_point(field_mutable_list:Proto_msg.Obstacle.acceleration_cov)
  return &acceleration_cov_;
}

// optional float acceleration_uncertainty = 28;
inline bool Obstacle::has_acceleration_uncertainty() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Obstacle::set_has_acceleration_uncertainty() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Obstacle::clear_has_acceleration_uncertainty() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Obstacle::clear_acceleration_uncertainty() {
  acceleration_uncertainty_ = 0;
  clear_has_acceleration_uncertainty();
}
inline float Obstacle::acceleration_uncertainty() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.acceleration_uncertainty)
  return acceleration_uncertainty_;
}
inline void Obstacle::set_acceleration_uncertainty(float value) {
  set_has_acceleration_uncertainty();
  acceleration_uncertainty_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.acceleration_uncertainty)
}

// optional .Proto_msg.Point3 ave_acceleration = 29;
inline bool Obstacle::has_ave_acceleration() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Obstacle::set_has_ave_acceleration() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Obstacle::clear_has_ave_acceleration() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Obstacle::clear_ave_acceleration() {
  if (ave_acceleration_ != NULL) ave_acceleration_->::Proto_msg::Point3::Clear();
  clear_has_ave_acceleration();
}
inline const ::Proto_msg::Point3& Obstacle::ave_acceleration() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.ave_acceleration)
  return ave_acceleration_ != NULL ? *ave_acceleration_ : *default_instance_->ave_acceleration_;
}
inline ::Proto_msg::Point3* Obstacle::mutable_ave_acceleration() {
  set_has_ave_acceleration();
  if (ave_acceleration_ == NULL) ave_acceleration_ = new ::Proto_msg::Point3;
  // @@protoc_insertion_point(field_mutable:Proto_msg.Obstacle.ave_acceleration)
  return ave_acceleration_;
}
inline ::Proto_msg::Point3* Obstacle::release_ave_acceleration() {
  clear_has_ave_acceleration();
  ::Proto_msg::Point3* temp = ave_acceleration_;
  ave_acceleration_ = NULL;
  return temp;
}
inline void Obstacle::set_allocated_ave_acceleration(::Proto_msg::Point3* ave_acceleration) {
  delete ave_acceleration_;
  ave_acceleration_ = ave_acceleration;
  if (ave_acceleration) {
    set_has_ave_acceleration();
  } else {
    clear_has_ave_acceleration();
  }
  // @@protoc_insertion_point(field_set_allocated:Proto_msg.Obstacle.ave_acceleration)
}

// optional float angle_velocity = 30;
inline bool Obstacle::has_angle_velocity() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Obstacle::set_has_angle_velocity() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Obstacle::clear_has_angle_velocity() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Obstacle::clear_angle_velocity() {
  angle_velocity_ = 0;
  clear_has_angle_velocity();
}
inline float Obstacle::angle_velocity() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.angle_velocity)
  return angle_velocity_;
}
inline void Obstacle::set_angle_velocity(float value) {
  set_has_angle_velocity();
  angle_velocity_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.angle_velocity)
}

// optional float angle_velocity_cov = 31;
inline bool Obstacle::has_angle_velocity_cov() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Obstacle::set_has_angle_velocity_cov() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Obstacle::clear_has_angle_velocity_cov() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Obstacle::clear_angle_velocity_cov() {
  angle_velocity_cov_ = 0;
  clear_has_angle_velocity_cov();
}
inline float Obstacle::angle_velocity_cov() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.angle_velocity_cov)
  return angle_velocity_cov_;
}
inline void Obstacle::set_angle_velocity_cov(float value) {
  set_has_angle_velocity_cov();
  angle_velocity_cov_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.angle_velocity_cov)
}

// optional float angle_velocity_uncertainty = 32;
inline bool Obstacle::has_angle_velocity_uncertainty() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Obstacle::set_has_angle_velocity_uncertainty() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Obstacle::clear_has_angle_velocity_uncertainty() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Obstacle::clear_angle_velocity_uncertainty() {
  angle_velocity_uncertainty_ = 0;
  clear_has_angle_velocity_uncertainty();
}
inline float Obstacle::angle_velocity_uncertainty() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.angle_velocity_uncertainty)
  return angle_velocity_uncertainty_;
}
inline void Obstacle::set_angle_velocity_uncertainty(float value) {
  set_has_angle_velocity_uncertainty();
  angle_velocity_uncertainty_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.angle_velocity_uncertainty)
}

// optional float ave_angle_velocity = 33;
inline bool Obstacle::has_ave_angle_velocity() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Obstacle::set_has_ave_angle_velocity() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Obstacle::clear_has_ave_angle_velocity() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Obstacle::clear_ave_angle_velocity() {
  ave_angle_velocity_ = 0;
  clear_has_ave_angle_velocity();
}
inline float Obstacle::ave_angle_velocity() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.ave_angle_velocity)
  return ave_angle_velocity_;
}
inline void Obstacle::set_ave_angle_velocity(float value) {
  set_has_ave_angle_velocity();
  ave_angle_velocity_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.ave_angle_velocity)
}

// optional float asso_quality = 34;
inline bool Obstacle::has_asso_quality() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Obstacle::set_has_asso_quality() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Obstacle::clear_has_asso_quality() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Obstacle::clear_asso_quality() {
  asso_quality_ = 0;
  clear_has_asso_quality();
}
inline float Obstacle::asso_quality() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.asso_quality)
  return asso_quality_;
}
inline void Obstacle::set_asso_quality(float value) {
  set_has_asso_quality();
  asso_quality_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.asso_quality)
}

// optional float tracker_quality = 35;
inline bool Obstacle::has_tracker_quality() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Obstacle::set_has_tracker_quality() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Obstacle::clear_has_tracker_quality() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void Obstacle::clear_tracker_quality() {
  tracker_quality_ = 0;
  clear_has_tracker_quality();
}
inline float Obstacle::tracker_quality() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.tracker_quality)
  return tracker_quality_;
}
inline void Obstacle::set_tracker_quality(float value) {
  set_has_tracker_quality();
  tracker_quality_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.tracker_quality)
}

// optional double tracking_time = 36;
inline bool Obstacle::has_tracking_time() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Obstacle::set_has_tracking_time() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Obstacle::clear_has_tracking_time() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void Obstacle::clear_tracking_time() {
  tracking_time_ = 0;
  clear_has_tracking_time();
}
inline double Obstacle::tracking_time() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacle.tracking_time)
  return tracking_time_;
}
inline void Obstacle::set_tracking_time(double value) {
  set_has_tracking_time();
  tracking_time_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacle.tracking_time)
}

// -------------------------------------------------------------------

// FreeSpaces

// optional double timestamp = 1;
inline bool FreeSpaces::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FreeSpaces::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FreeSpaces::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FreeSpaces::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double FreeSpaces::timestamp() const {
  // @@protoc_insertion_point(field_get:Proto_msg.FreeSpaces.timestamp)
  return timestamp_;
}
inline void FreeSpaces::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.FreeSpaces.timestamp)
}

// optional uint32 seq = 2;
inline bool FreeSpaces::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FreeSpaces::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FreeSpaces::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FreeSpaces::clear_seq() {
  seq_ = 0u;
  clear_has_seq();
}
inline ::google::protobuf::uint32 FreeSpaces::seq() const {
  // @@protoc_insertion_point(field_get:Proto_msg.FreeSpaces.seq)
  return seq_;
}
inline void FreeSpaces::set_seq(::google::protobuf::uint32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.FreeSpaces.seq)
}

// optional string parent_frame_id = 3;
inline bool FreeSpaces::has_parent_frame_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FreeSpaces::set_has_parent_frame_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FreeSpaces::clear_has_parent_frame_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FreeSpaces::clear_parent_frame_id() {
  if (parent_frame_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_frame_id_->clear();
  }
  clear_has_parent_frame_id();
}
inline const ::std::string& FreeSpaces::parent_frame_id() const {
  // @@protoc_insertion_point(field_get:Proto_msg.FreeSpaces.parent_frame_id)
  return *parent_frame_id_;
}
inline void FreeSpaces::set_parent_frame_id(const ::std::string& value) {
  set_has_parent_frame_id();
  if (parent_frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_frame_id_ = new ::std::string;
  }
  parent_frame_id_->assign(value);
  // @@protoc_insertion_point(field_set:Proto_msg.FreeSpaces.parent_frame_id)
}
inline void FreeSpaces::set_parent_frame_id(const char* value) {
  set_has_parent_frame_id();
  if (parent_frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_frame_id_ = new ::std::string;
  }
  parent_frame_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proto_msg.FreeSpaces.parent_frame_id)
}
inline void FreeSpaces::set_parent_frame_id(const char* value, size_t size) {
  set_has_parent_frame_id();
  if (parent_frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_frame_id_ = new ::std::string;
  }
  parent_frame_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proto_msg.FreeSpaces.parent_frame_id)
}
inline ::std::string* FreeSpaces::mutable_parent_frame_id() {
  set_has_parent_frame_id();
  if (parent_frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_frame_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proto_msg.FreeSpaces.parent_frame_id)
  return parent_frame_id_;
}
inline ::std::string* FreeSpaces::release_parent_frame_id() {
  clear_has_parent_frame_id();
  if (parent_frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = parent_frame_id_;
    parent_frame_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FreeSpaces::set_allocated_parent_frame_id(::std::string* parent_frame_id) {
  if (parent_frame_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete parent_frame_id_;
  }
  if (parent_frame_id) {
    set_has_parent_frame_id();
    parent_frame_id_ = parent_frame_id;
  } else {
    clear_has_parent_frame_id();
    parent_frame_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proto_msg.FreeSpaces.parent_frame_id)
}

// optional string frame_id = 4;
inline bool FreeSpaces::has_frame_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FreeSpaces::set_has_frame_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FreeSpaces::clear_has_frame_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FreeSpaces::clear_frame_id() {
  if (frame_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frame_id_->clear();
  }
  clear_has_frame_id();
}
inline const ::std::string& FreeSpaces::frame_id() const {
  // @@protoc_insertion_point(field_get:Proto_msg.FreeSpaces.frame_id)
  return *frame_id_;
}
inline void FreeSpaces::set_frame_id(const ::std::string& value) {
  set_has_frame_id();
  if (frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frame_id_ = new ::std::string;
  }
  frame_id_->assign(value);
  // @@protoc_insertion_point(field_set:Proto_msg.FreeSpaces.frame_id)
}
inline void FreeSpaces::set_frame_id(const char* value) {
  set_has_frame_id();
  if (frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frame_id_ = new ::std::string;
  }
  frame_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proto_msg.FreeSpaces.frame_id)
}
inline void FreeSpaces::set_frame_id(const char* value, size_t size) {
  set_has_frame_id();
  if (frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frame_id_ = new ::std::string;
  }
  frame_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proto_msg.FreeSpaces.frame_id)
}
inline ::std::string* FreeSpaces::mutable_frame_id() {
  set_has_frame_id();
  if (frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frame_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proto_msg.FreeSpaces.frame_id)
  return frame_id_;
}
inline ::std::string* FreeSpaces::release_frame_id() {
  clear_has_frame_id();
  if (frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = frame_id_;
    frame_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FreeSpaces::set_allocated_frame_id(::std::string* frame_id) {
  if (frame_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete frame_id_;
  }
  if (frame_id) {
    set_has_frame_id();
    frame_id_ = frame_id;
  } else {
    clear_has_frame_id();
    frame_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proto_msg.FreeSpaces.frame_id)
}

// repeated .Proto_msg.FreeSpace freeSpaces = 5;
inline int FreeSpaces::freespaces_size() const {
  return freespaces_.size();
}
inline void FreeSpaces::clear_freespaces() {
  freespaces_.Clear();
}
inline const ::Proto_msg::FreeSpace& FreeSpaces::freespaces(int index) const {
  // @@protoc_insertion_point(field_get:Proto_msg.FreeSpaces.freeSpaces)
  return freespaces_.Get(index);
}
inline ::Proto_msg::FreeSpace* FreeSpaces::mutable_freespaces(int index) {
  // @@protoc_insertion_point(field_mutable:Proto_msg.FreeSpaces.freeSpaces)
  return freespaces_.Mutable(index);
}
inline ::Proto_msg::FreeSpace* FreeSpaces::add_freespaces() {
  // @@protoc_insertion_point(field_add:Proto_msg.FreeSpaces.freeSpaces)
  return freespaces_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto_msg::FreeSpace >&
FreeSpaces::freespaces() const {
  // @@protoc_insertion_point(field_list:Proto_msg.FreeSpaces.freeSpaces)
  return freespaces_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto_msg::FreeSpace >*
FreeSpaces::mutable_freespaces() {
  // @@protoc_insertion_point(field_mutable_list:Proto_msg.FreeSpaces.freeSpaces)
  return &freespaces_;
}

// -------------------------------------------------------------------

// Obstacles

// optional double timestamp = 1;
inline bool Obstacles::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Obstacles::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Obstacles::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Obstacles::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double Obstacles::timestamp() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacles.timestamp)
  return timestamp_;
}
inline void Obstacles::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacles.timestamp)
}

// optional uint32 seq = 2;
inline bool Obstacles::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Obstacles::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Obstacles::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Obstacles::clear_seq() {
  seq_ = 0u;
  clear_has_seq();
}
inline ::google::protobuf::uint32 Obstacles::seq() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacles.seq)
  return seq_;
}
inline void Obstacles::set_seq(::google::protobuf::uint32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacles.seq)
}

// optional string parent_frame_id = 3;
inline bool Obstacles::has_parent_frame_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Obstacles::set_has_parent_frame_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Obstacles::clear_has_parent_frame_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Obstacles::clear_parent_frame_id() {
  if (parent_frame_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_frame_id_->clear();
  }
  clear_has_parent_frame_id();
}
inline const ::std::string& Obstacles::parent_frame_id() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacles.parent_frame_id)
  return *parent_frame_id_;
}
inline void Obstacles::set_parent_frame_id(const ::std::string& value) {
  set_has_parent_frame_id();
  if (parent_frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_frame_id_ = new ::std::string;
  }
  parent_frame_id_->assign(value);
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacles.parent_frame_id)
}
inline void Obstacles::set_parent_frame_id(const char* value) {
  set_has_parent_frame_id();
  if (parent_frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_frame_id_ = new ::std::string;
  }
  parent_frame_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proto_msg.Obstacles.parent_frame_id)
}
inline void Obstacles::set_parent_frame_id(const char* value, size_t size) {
  set_has_parent_frame_id();
  if (parent_frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_frame_id_ = new ::std::string;
  }
  parent_frame_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proto_msg.Obstacles.parent_frame_id)
}
inline ::std::string* Obstacles::mutable_parent_frame_id() {
  set_has_parent_frame_id();
  if (parent_frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_frame_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proto_msg.Obstacles.parent_frame_id)
  return parent_frame_id_;
}
inline ::std::string* Obstacles::release_parent_frame_id() {
  clear_has_parent_frame_id();
  if (parent_frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = parent_frame_id_;
    parent_frame_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Obstacles::set_allocated_parent_frame_id(::std::string* parent_frame_id) {
  if (parent_frame_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete parent_frame_id_;
  }
  if (parent_frame_id) {
    set_has_parent_frame_id();
    parent_frame_id_ = parent_frame_id;
  } else {
    clear_has_parent_frame_id();
    parent_frame_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proto_msg.Obstacles.parent_frame_id)
}

// optional string frame_id = 4;
inline bool Obstacles::has_frame_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Obstacles::set_has_frame_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Obstacles::clear_has_frame_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Obstacles::clear_frame_id() {
  if (frame_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frame_id_->clear();
  }
  clear_has_frame_id();
}
inline const ::std::string& Obstacles::frame_id() const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacles.frame_id)
  return *frame_id_;
}
inline void Obstacles::set_frame_id(const ::std::string& value) {
  set_has_frame_id();
  if (frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frame_id_ = new ::std::string;
  }
  frame_id_->assign(value);
  // @@protoc_insertion_point(field_set:Proto_msg.Obstacles.frame_id)
}
inline void Obstacles::set_frame_id(const char* value) {
  set_has_frame_id();
  if (frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frame_id_ = new ::std::string;
  }
  frame_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proto_msg.Obstacles.frame_id)
}
inline void Obstacles::set_frame_id(const char* value, size_t size) {
  set_has_frame_id();
  if (frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frame_id_ = new ::std::string;
  }
  frame_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proto_msg.Obstacles.frame_id)
}
inline ::std::string* Obstacles::mutable_frame_id() {
  set_has_frame_id();
  if (frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    frame_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proto_msg.Obstacles.frame_id)
  return frame_id_;
}
inline ::std::string* Obstacles::release_frame_id() {
  clear_has_frame_id();
  if (frame_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = frame_id_;
    frame_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Obstacles::set_allocated_frame_id(::std::string* frame_id) {
  if (frame_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete frame_id_;
  }
  if (frame_id) {
    set_has_frame_id();
    frame_id_ = frame_id;
  } else {
    clear_has_frame_id();
    frame_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proto_msg.Obstacles.frame_id)
}

// repeated .Proto_msg.Obstacle obstacles = 5;
inline int Obstacles::obstacles_size() const {
  return obstacles_.size();
}
inline void Obstacles::clear_obstacles() {
  obstacles_.Clear();
}
inline const ::Proto_msg::Obstacle& Obstacles::obstacles(int index) const {
  // @@protoc_insertion_point(field_get:Proto_msg.Obstacles.obstacles)
  return obstacles_.Get(index);
}
inline ::Proto_msg::Obstacle* Obstacles::mutable_obstacles(int index) {
  // @@protoc_insertion_point(field_mutable:Proto_msg.Obstacles.obstacles)
  return obstacles_.Mutable(index);
}
inline ::Proto_msg::Obstacle* Obstacles::add_obstacles() {
  // @@protoc_insertion_point(field_add:Proto_msg.Obstacles.obstacles)
  return obstacles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto_msg::Obstacle >&
Obstacles::obstacles() const {
  // @@protoc_insertion_point(field_list:Proto_msg.Obstacles.obstacles)
  return obstacles_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proto_msg::Obstacle >*
Obstacles::mutable_obstacles() {
  // @@protoc_insertion_point(field_mutable_list:Proto_msg.Obstacles.obstacles)
  return &obstacles_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto_msg

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Proto_msg::Obstacle_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto_msg::Obstacle_Type>() {
  return ::Proto_msg::Obstacle_Type_descriptor();
}
template <> struct is_proto_enum< ::Proto_msg::Obstacle_MotionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto_msg::Obstacle_MotionType>() {
  return ::Proto_msg::Obstacle_MotionType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Proto_5fmsg_2ePercept_2eproto__INCLUDED
